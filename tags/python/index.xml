<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>python on what did I learn today</title>
    <link>https://ridingintraffic.github.io/tags/python/</link>
    <description>Recent content in python on what did I learn today</description>
    <image>
      <url>https://ridingintraffic.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://ridingintraffic.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 23 May 2023 00:00:00 -0500</lastBuildDate><atom:link href="https://ridingintraffic.github.io/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>python base64 requests jq and terraform</title>
      <link>https://ridingintraffic.github.io/posts/2023-05-23-jq-terraform-python-requests/</link>
      <pubDate>Tue, 23 May 2023 00:00:00 -0500</pubDate>
      
      <guid>https://ridingintraffic.github.io/posts/2023-05-23-jq-terraform-python-requests/</guid>
      <description>base64 uaer auth in requests use the base64 for the first header and then reuse the bearer token that you get back.
headers = { &amp;#39;Content-Type&amp;#39;: &amp;#39;application/json&amp;#39;, &amp;#39;Accept&amp;#39;: &amp;#39;application/json&amp;#39; } base_url = &amp;#39;https://www.something.com&amp;#39; token_url = &amp;#34;/tauth/1.0/token/&amp;#34; url=base_url + token_url response = requests.post(url, headers=headers, auth=HTTPBasicAuth(USER, PASSWORD)) data = response.json() #reusing that bearer token from the repsonse headers = { &amp;#39;Authorization&amp;#39;: f&amp;#34;Bearer {data[&amp;#39;token&amp;#39;]}&amp;#34;, &amp;#39;Content-Type&amp;#39;: &amp;#39;application/json&amp;#39;, &amp;#39;Accept&amp;#39;: &amp;#39;application/json&amp;#39; } url=&amp;#34;/something/&amp;#34; response=requests.get( url, headers=headers) data = response.</description>
    </item>
    
    <item>
      <title>python nested dictionary access</title>
      <link>https://ridingintraffic.github.io/posts/2023-04-27-python-nesting/</link>
      <pubDate>Thu, 27 Apr 2023 00:00:00 -0500</pubDate>
      
      <guid>https://ridingintraffic.github.io/posts/2023-04-27-python-nesting/</guid>
      <description>Getting dictionaries back from a http endpoint usually results in a mess of objects. Dealing with this in python can be a challenge of ValueError exceptions. so what is the easiest way to handle this? a nested get. if the object looks like
message={&amp;#34;detail&amp;#34;:{&amp;#34;operation&amp;#34;:&amp;#34;create&amp;#34;}} then you can access it like this
message.get(&amp;#39;detail&amp;#39;, {}).get(&amp;#39;operation&amp;#39;) then if you access something that doesn&amp;rsquo;t exist you will get a nice None back
&amp;gt;&amp;gt;&amp;gt; print(message.get(&amp;#39;detail&amp;#39;, {}).</description>
    </item>
    
    <item>
      <title>python repl</title>
      <link>https://ridingintraffic.github.io/posts/2021-09-16-repl/</link>
      <pubDate>Thu, 16 Sep 2021 00:00:00 -0500</pubDate>
      
      <guid>https://ridingintraffic.github.io/posts/2021-09-16-repl/</guid>
      <description>Using repl to debug python.
https://jvns.ca/blog/2021/09/16/debugging-in-a-repl-is-fun/
what’s a REPL? REPL stands for “read eval print loop”. A REPL is a program that: reads some input from you like print(f&amp;#34;2 + 2 = {2+2}&amp;#34;) (read) evaluates the input (eval) print out the result (print) and then goes back to step 1 (loop) A couple years ago I used pry in ruby/chef a bunch and then I guess I forgot about it. Now this works for python too and it is WAY better than my print statement hell that I usually write.</description>
    </item>
    
    <item>
      <title>pythonic list find</title>
      <link>https://ridingintraffic.github.io/posts/2019-06-06-pythonic-list-find/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ridingintraffic.github.io/posts/2019-06-06-pythonic-list-find/</guid>
      <description>finding an item in a list python can do a lot of smart things, lets use the python way of finding items in a list.
#python 3 tags=[ { &amp;#34;Key&amp;#34;: &amp;#34;CreationDate&amp;#34;, &amp;#34;Value&amp;#34;: &amp;#34;201904011158&amp;#34; }, { &amp;#34;Key&amp;#34;: &amp;#34;Name&amp;#34;, &amp;#34;Value&amp;#34;: &amp;#34;mymagicserver&amp;#34; }, { &amp;#34;Key&amp;#34;: &amp;#34;aws:autoscaling:groupName&amp;#34;, &amp;#34;Value&amp;#34;: &amp;#34;my-rad-asg&amp;#34; }, { &amp;#34;Key&amp;#34;: &amp;#34;Environment&amp;#34;, &amp;#34;Value&amp;#34;: &amp;#34;cloudy&amp;#34; }, { &amp;#34;Key&amp;#34;: &amp;#34;name&amp;#34;, &amp;#34;Value&amp;#34;: &amp;#34;john&amp;#34; }, { &amp;#34;Key&amp;#34;: &amp;#34;Department&amp;#34;, &amp;#34;Value&amp;#34;: &amp;#34;sporting goods&amp;#34; }, { &amp;#34;Key&amp;#34;: &amp;#34;Auto-Off&amp;#34;, &amp;#34;Value&amp;#34;: &amp;#34;no&amp;#34; } ] data = list(filter(lambda x: x[&amp;#34;Key&amp;#34;] == &amp;#34;aws:autoscaling:groupName&amp;#34; , tags)) print(data[0][&amp;#34;Value&amp;#34;]) ##brute force way: def bruteforce(mylist) for item in mylist: if item[&amp;#34;Key&amp;#34;] == &amp;#34;aws:autoscaling:groupName&amp;#34;: return item[&amp;#34;Value&amp;#34;] print(bruteforce(tags)) </description>
    </item>
    
  </channel>
</rss>
